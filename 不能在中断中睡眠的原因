为什么不能在中断中睡眠或者调度？

1、schedule函数中会检测是否在中断上下文中，如果是就BUG了，高版本去掉这个检测了，但这不是不能睡眠的原因，这是linux的限制，如果去掉呢？
   肯定就可以了
2、破坏现场、没有进程context不能被调度、睡眠了没法被唤醒，这些都不是理由！
   破坏现场，下次先返回到中断，再返回到user，现场不就回来了
   没有进程上下文不能被调度，就以被中断的进程为环境接收调度有何不可，和内核抢占一个道理
   睡眠了没法唤醒，这也不是理由，就以被中断的进程睡眠在需要等待的资源上，有资源了返回，先返回到中断，再返回到用户态，没有问题


最主要的原因是关中断了，假设在硬中断的上下文接受调度，确实可以调度到下一进程，然后下一个进程怎么办，会一直运行，因为时钟中断被关闭了，不能打断用户态了，只能等该进程自己主动放弃cpu或者运行结束，而且其后一直都需要进程的自觉
如果是软中断上下文呢？只是关闭了软中断，会影响所有的软中断，那么所有硬中断可以执行，软中断都被block

真的实现了这样，会让中断延迟处理，这不符合中断紧迫性的特点。技术上完全可行

网上说：这是一个设计问题

确实是一个设计问题，linux只是通过各个地方判断检测，拒绝这种行为。如果不加拦截，强行调度是可以的，也可以运行一会，但要靠进程自觉，而且中断都被耽误着。
